#!/bin/sh

postgresql_initialize()
{
  package initialize
  service initialize

  package_dependencies=(readline)

  if user is root
  then
    if [[ "${package_user}" = "postgresql" || -z ${package_user} ]]
    then
      package_user="postgres"
    fi
  else
    package_user="$USER"
    prefix_path="$HOME/.sm"
  fi

  configure_flags=( --with-readline-dir="${active_path}/lib" )

  true ${service_port:=5432} ${service_bind_interface:="127.0.0.1"} \
    ${service_user:=${package_user}}

  service_binary="${service_bin_path}/pg_ctl"
  service_cli_binary="${service_bin_path}/psql"

  if array is empty service_flags
  then
    _action="${action//\(*}"
    service_flags+=(${_action//*_} -D "$service_data_path/data" -s )
    service_stop_flags+=( -m fast -w )
  fi

  export PGDATA="${service_data_path}/data"

  service_pid_file="${service_data_path}/data/postmaster.pid"
}

postgresql_prefetch()
{
  package define \
    base_url "http://ftp9.us.postgresql.org/pub/mirrors/postgresql/source/v${package_version}"
}

postgresql_postinstall()
{
  user create unless exists \
    name "${service_user}" shell "/sbin/nologin"

  postgresql_init_script
  postgresql_conf_d
  postgresql_kernel_parameters

  log "
  Installation and configuration of postgresql is now complete.

  * postgresql has been installed to $install_path
  * postgresql configuration and data files will are in $service_data_path
  * You can control the postgresql server via the bdsm postgresql extension'
  * The postgersql superuser is '$service_user', no password.
  * Use /etc/conf.d/postgresql.conf for server startup customization.

  "
}

postgresql_conf_update()
{
  files replace content "^.*data_directory.*" \
    with "data_directory = '${service_db_path}/active/data'" \
    in "${service_data_path}/postgresql.conf"

  files replace content "^.*hba_file.*" \
    with "hba_file = '${service_db_path}'" \
    in "${service_data_path}/postgresql.conf"

  files replace content "^.*ident_file.*" \
    with "ident_file = '${service_pid_file}'" \
    in "${service_data_path}/postgresql.conf"

  files replace content "^.*listen_address.*" \
    with "listen_address = '*'" \
    in "${service_data_path}/postgresql.conf"

  files replace content "^.*max_connections.*" \
    with "max_connections = '50'" \
    in "${service_data_path}/postgresql.conf"

  files replace content "^.*unix_socket_directory.*" \
    with "unix_socket_directory = '${service_pid_path}'" \
    in "${service_data_path}/postgresql.conf"

  files replace content "^.*shared_buffers.*" \
    with "shared_buffers = '64MB'" \
    in "${service_data_path}/postgresql.conf"
}

postgresql_kernel_parameters()
{
  true # TODO: Cross the finish line!!!
}

postgresql_database_setup()
{
  log "Initializing postgresql data directory in $service_data_path"
  path create "${service_data_path}"
  paths chown recursive "$service_user:$service_user" "${service_data_path}"

  command="'$install_path/bin/initdb' --pgdata='${service_data_path}/data' --encoding=utf8 --username=$service_user"

  files copy force \
    to "${service_data_path}" \
    "${install_path}"/share/*.sample

  if user is root
  then
    su - "${service_user}" -c "${command}"
  else
    "${command}"
  fi

  paths chown recursive "$service_user:$service_user" "${service_data_path}"
  paths chmod recursive 0700 "${service_data_path}"
}

postgresql_service_setup()
{
  local file _entries
  log "Configuring postgresql server."

  paths create "${service_data_path}" "${log_path}"

  postgresql_database_setup

  link --force "${service_data_path}" to "${data_base_path}/active"

  log "service_data_path: ${service_data_path}"
  for file in postgresql pg_hba pg_ident recovery
  do
    if ! file is nonempty "${service_data_path}/${file}.conf"
    then
      if ! file exists "$service_data_path/${file}.conf.sample"
      then
        log "Missing $service_data_path/${file}.conf.sample, skipping."
        continue
      fi
      log "Installing ${file}.conf to ${service_data_path}/"

      files copy force \
        from "$service_data_path/${file}.conf.sample" \
        to "$service_data_path/${file}.conf"

      if file is missing "${service_config_path}/${file}.conf"
      then
        link "$service_data_path/${file}.conf" \
          to "${service_config_path}/${file}.conf"
      fi
    fi
  done

  postgresql_conf_update

  path chown recursive "$service_user" "$data_base_path"

  find "${service_data_path}" -type f -print0 | xargs -0 chmod 0600
  find "${service_data_path}" -type d -print0 | xargs -0 chmod 0700
}

postgresql_init_script()
{
  log "Installing Postgresql init script"
  template install "postgresql/postgresql" \
    to "${init_scripts_path}/postgresql" mode 0755
}

postgresql_conf_d()
{
  log "Installing Postgresql conf.d script"

  path create "${confd_path}"

  template install "postgresql/postgresql.conf.d" \
    to "${confd_path}/postgresql.conf" \
    mode 0644

  template seed "/etc/conf.d/postgresql.conf" \
    packages_path "${packages_path}" \
    service_data_path "${service_data_path}"
}

postgresql_preconfigure()
{
  if [[ "$action" = *install ]]
  then
    configure_flags=(
      --prefix="${install_base_path}/${package_version}"
      --datadir="${install_base_path}/${package_version}/data"
      --with-openssl
      --enable-shared
    )

    if os is darwin
    then
      configure_flags[${#configure_flags[@]}]="--with-bonjour"
    fi

    export CFLAGS='-O2'
  fi
}

# TODO: Enable this at the service level.
postgresql_reload()
{
  log "Reload PostgreSQL Server configuration"

  su - "${service_user}" -c "$control reload -D '${service_data_path}' -s"
}

